// File: config/db.js
// config/db.js
import mongoose from 'mongoose';

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected');
  } catch (error) {
    console.error('Error connecting to MongoDB:', error.message);
    process.exit(1);
  }
};

export default connectDB;

// File: controllers/authController.js
// controllers/authController.js
import asyncHandler from 'express-async-handler';
import User from '../models/User.js';
import generateToken from '../utils/generateToken.js';

// @desc    Register a new user
// @route   POST /api/account/signup
// @access  Public
const registerUser = asyncHandler(async (req, res) => {
  const { name, companyType, username, email, password } = req.body;

  const userExists = await User.findOne({ email });

  if (userExists) {
    res.status(400);
    throw new Error('User already exists');
  }

  const user = await User.create({
    name,
    companyType,
    username,
    email,
    password,
  });

  if (user) {
    res.status(201).json({
      _id: user._id,
      name: user.name,
      username: user.username,
      email: user.email,
      token: generateToken(user._id),
    });
  } else {
    res.status(400);
    throw new Error('Invalid user data');
  }
});

// @desc    Auth user & get token
// @route   POST /api/account/signin
// @access  Public
const authUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  const user = await User.findOne({ email });

  if (user && (await user.matchPassword(password))) {
    res.json({
      _id: user._id,
      name: user.name,
      username: user.username,
      email: user.email,
      token: generateToken(user._id),
    });
  } else {
    res.status(401);
    throw new Error('Invalid email or password');
  }
});

export { registerUser, authUser };

// File: middleware/authMiddleware.js
// middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import User from '../models/User.js';

const protect = async (req, res, next) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = await User.findById(decoded.id).select('-password');
      next();
    } catch (error) {
      console.error('Not authorized, token failed', error);
      res.status(401).json({ message: 'Not authorized, token failed' });
    }
  } else {
    res.status(401).json({ message: 'Not authorized, no token' });
  }
};

export { protect };

// File: models/InterviewBatch.js
// models/interviewBatchSchema.js
import mongoose from 'mongoose';

const interviewBatchSchema = new mongoose.Schema({
  companyName: { type: String, required: true },
  totalCandidatesRequired: { type: Number, required: true },
  domains: { type: String, required: true },
  skills: { type: [String], required: true },
  interviewTypes: { type: [String], required: true },
  deadline: { type: Date, required: true },
  csvFile: { type: String, required: true },
}, {
  timestamps: true,
});

export default mongoose.model('InterviewBatch', interviewBatchSchema);

// File: models/User.js
// models/User.js
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  companyType: { type: String, required: true },
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
}, {
  timestamps: true
});

// Encrypt password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', userSchema);

export default User;

// File: routes/authRoutes.js
// routes/authRoutes.js
import express from 'express';
import { registerUser, authUser } from '../controllers/authController.js';

const router = express.Router();

router.post('/signup', registerUser);
router.post('/signin', authUser);

export default router;

// File: routes/getInterviewBatchRoutes.js
// routes/getInterviewBatchRoutes.js
import express from 'express';
import InterviewBatch from '../models/InterviewBatch.js';

const router = express.Router();

// Fetch all interview batches
router.get('/interviewBatch', async (req, res) => {
  try {
    const interviewBatches = await InterviewBatch.find();
    res.status(200).json(interviewBatches);
  } catch (error) {
    console.error('Error fetching interview batches:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
});

export default router;

// File: routes/interviewBatchRoutes.js
// routes/interviewBatchRoutes.js
import express from 'express';
import InterviewBatch from '../models/InterviewBatch.js';
import multer from 'multer';

const storage = multer.memoryStorage();
const upload = multer({ storage: storage });
const router = express.Router();

// Create a new interview batch
router.post('/interviewBatch', upload.single('csvFile'), async (req, res) => {
  try {
    const interviewBatch = new InterviewBatch({
      companyName: req.body.companyName,
      totalCandidatesRequired: req.body.totalCandidatesRequired,
      domains: req.body.domains,
      skills: JSON.parse(req.body.skills),
      interviewTypes: JSON.parse(req.body.interviewTypes),
      deadline: req.body.deadline,
      csvFile: req.file.buffer.toString('base64')
    });

    await interviewBatch.save();
    res.status(201).json({ message: 'Interview batch created successfully' });
  } catch (error) {
    console.error('Error creating interview batch:', error);
    res.status(400).json({ message: error.message });
  }
});

export default router;

// File:# .env   
PORT=3000
MONGODB_URI="mongodb+srv://nameunknown631:V91TxLbV6RbG3w2b@cluster0.8e5wpse.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"
JWT_SECRET="rrt543efdgtreft6rtr6"